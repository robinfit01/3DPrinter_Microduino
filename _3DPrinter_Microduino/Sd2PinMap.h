/* Arduino SdFat Library
 * Copyright (C) 2010 by William Greiman
 *
 * This file is part of the Arduino SdFat Library
 *
 * This Library is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This Library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with the Arduino SdFat Library.  If not, see
 * <http://www.gnu.org/licenses/>.
 */
// Warning this file was generated by a program.
#include "Marlin.h"
#ifdef SDSUPPORT

#ifndef Sd2PinMap_h
#define Sd2PinMap_h
#include <avr/io.h>
//------------------------------------------------------------------------------
/** struct for mapping digital pins */
struct pin_map_t {
  volatile uint8_t* ddr;
  volatile uint8_t* pin;
  volatile uint8_t* port;
  uint8_t bit;
};
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Microduino Compatible
#if defined(__AVR_ATmega644P__)\
|| defined(__AVR_ATmega644__)\
|| defined(__AVR_ATmega1284P__)

// Two Wire (aka I2C) ports
uint8_t const SDA_PIN = 20;  // C1
uint8_t const SCL_PIN = 21;  // C2

// SPI port
uint8_t const SS_PIN = 10;    // B4
uint8_t const MOSI_PIN = 11;  // B5
uint8_t const MISO_PIN = 12;  // B6
uint8_t const SCK_PIN = 13;   // B7

static const pin_map_t digitalPinMap[] = {  
  {&DDRD, &PIND, &PORTD, 0},  // D0 PD0
  {&DDRD, &PIND, &PORTD, 1},  // D1 PD1
  {&DDRD, &PIND, &PORTD, 2},  // D2 PD2
  {&DDRD, &PIND, &PORTD, 3},  // D3 PD3
  {&DDRB, &PINB, &PORTB, 0},  // D4 PB0
  {&DDRB, &PINB, &PORTB, 1},  // D5 PB1
  {&DDRB, &PINB, &PORTB, 2},  // D6 PB2
  {&DDRB, &PINB, &PORTB, 3},  // D7 PB3
  {&DDRD, &PIND, &PORTD, 6},  // D8 PD6
  {&DDRD, &PIND, &PORTD, 5},  // D9 PD5
  {&DDRB, &PINB, &PORTB, 4},  // D10 PB4
  {&DDRB, &PINB, &PORTB, 5},  // D11 PB5
  {&DDRB, &PINB, &PORTB, 6},  // D12 PB6
  {&DDRB, &PINB, &PORTB, 7},  // D13 PB7
  {&DDRC, &PINC, &PORTC, 7},  // D14 PC7
  {&DDRC, &PINC, &PORTC, 6},  // D15 PC6
  {&DDRC, &PINC, &PORTC, 5},  // D16 PC5
  {&DDRC, &PINC, &PORTC, 4},  // D17 PC4
  {&DDRC, &PINC, &PORTC, 3},  // D18 PC3
  {&DDRC, &PINC, &PORTC, 2},  // D19 PC2
  {&DDRC, &PINC, &PORTC, 1},  // D20 PC1
  {&DDRC, &PINC, &PORTC, 0},  // D21 PC0
  {&DDRD, &PIND, &PORTD, 4},  // D22 PD4
  {&DDRD, &PIND, &PORTD, 7},  // D23 PD7
  {&DDRA, &PINA, &PORTA, 7},  // D24 PA7
  {&DDRA, &PINA, &PORTA, 6},  // D25 PA6
  {&DDRA, &PINA, &PORTA, 5},  // D26 PA5
  {&DDRA, &PINA, &PORTA, 4},  // D27 PA4
  {&DDRA, &PINA, &PORTA, 3},  // D28 PA3
  {&DDRA, &PINA, &PORTA, 2},  // D29 PA2
  {&DDRA, &PINA, &PORTA, 1},  // D30 PA1
  {&DDRA, &PINA, &PORTA, 0}   // D31 PA0
};

//------------------------------------------------------------------------------
#elif defined(__AVR_ATmega168__)\
||defined(__AVR_ATmega168P__)\
||defined(__AVR_ATmega328P__)
// 168 and 328 Arduinos

// Two Wire (aka I2C) ports
uint8_t const SDA_PIN = 18;  // C4
uint8_t const SCL_PIN = 19;  // C5

// SPI port
uint8_t const SS_PIN = 10;    // B2
uint8_t const MOSI_PIN = 11;  // B3
uint8_t const MISO_PIN = 12;  // B4
uint8_t const SCK_PIN = 13;   // B5

static const pin_map_t digitalPinMap[] = {
  {&DDRD, &PIND, &PORTD, 0},  // D0  0
  {&DDRD, &PIND, &PORTD, 1},  // D1  1
  {&DDRD, &PIND, &PORTD, 2},  // D2  2
  {&DDRD, &PIND, &PORTD, 3},  // D3  3
  {&DDRD, &PIND, &PORTD, 4},  // D4  4
  {&DDRD, &PIND, &PORTD, 5},  // D5  5
  {&DDRD, &PIND, &PORTD, 6},  // D6  6
  {&DDRD, &PIND, &PORTD, 7},  // D7  7
  {&DDRB, &PINB, &PORTB, 0},  // B0  8
  {&DDRB, &PINB, &PORTB, 1},  // B1  9
  {&DDRB, &PINB, &PORTB, 2},  // B2 10
  {&DDRB, &PINB, &PORTB, 3},  // B3 11
  {&DDRB, &PINB, &PORTB, 4},  // B4 12
  {&DDRB, &PINB, &PORTB, 5},  // B5 13
  {&DDRC, &PINC, &PORTC, 0},  // C0 14
  {&DDRC, &PINC, &PORTC, 1},  // C1 15
  {&DDRC, &PINC, &PORTC, 2},  // C2 16
  {&DDRC, &PINC, &PORTC, 3},  // C3 17
  {&DDRC, &PINC, &PORTC, 4},  // C4 18
  {&DDRC, &PINC, &PORTC, 5}   // C5 19
};
#else
#error unknown chip
#endif
//------------------------------------------------------------------------------
static const uint8_t digitalPinCount = sizeof(digitalPinMap)/sizeof(pin_map_t);

uint8_t badPinNumber(void)
  __attribute__((error("Pin number is too large or not a constant")));

static inline __attribute__((always_inline))
  bool getPinMode(uint8_t pin) {
  if (__builtin_constant_p(pin) && pin < digitalPinCount) {
    return (*digitalPinMap[pin].ddr >> digitalPinMap[pin].bit) & 1;
  } else {
    return badPinNumber();
  }
}
static inline __attribute__((always_inline))
  void setPinMode(uint8_t pin, uint8_t mode) {
  if (__builtin_constant_p(pin) && pin < digitalPinCount) {
    if (mode) {
      *digitalPinMap[pin].ddr |= 1 << digitalPinMap[pin].bit;
    } else {
      *digitalPinMap[pin].ddr &= ~(1 << digitalPinMap[pin].bit);
    }
  } else {
    badPinNumber();
  }
}
static inline __attribute__((always_inline))
  bool fastDigitalRead(uint8_t pin) {
  if (__builtin_constant_p(pin) && pin < digitalPinCount) {
    return (*digitalPinMap[pin].pin >> digitalPinMap[pin].bit) & 1;
  } else {
    return badPinNumber();
  }
}
static inline __attribute__((always_inline))
  void fastDigitalWrite(uint8_t pin, uint8_t value) {
  if (__builtin_constant_p(pin) && pin < digitalPinCount) {
    if (value) {
      *digitalPinMap[pin].port |= 1 << digitalPinMap[pin].bit;
    } else {
      *digitalPinMap[pin].port &= ~(1 << digitalPinMap[pin].bit);
    }
  } else {
    badPinNumber();
  }
}
#endif  // Sd2PinMap_h


#endif
